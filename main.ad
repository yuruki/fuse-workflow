= Real World Enterprise Workflow for Red Hat JBoss Fuse
Jyrki Ruuskanen, Finavia Corporation, 2014
:backend: deckjs
:deckjs_theme: swiss
:status:
:split:

== Where do we start from?

* A team of 2-3 developers who also operate the environments (got the Devs and the Ops right there).
* Red Hat JBoss Fuse license for 16 processor cores.
* Green light from the bosses to make Fuse our new integration platform.

=== What are we trying to achieve?

* A highly available setup manageable by a small team.
* Manual steps kept at minimum, while keeping the setup simple.
* Everything versioned and reversible.

[options="step"]
--
[plantuml, profit, svg]
....
start
#PaleTurquoise:Cool, we're good to go;
:?;
#PaleGreen:Profit!;
stop
....

That's the idea. Now let's go through what we got...
--

== Step 1: Create a bundle project

[plantuml, step1_workflow, svg]
....
|Developer|
start
#PaleTurquoise:Create a bundle project;
:Work on the project;
|#PaleGreen|Nexus|
....

[options="step"]
To deploy something in Fuse we first have to create a deployable artifact. In our case we create and deploy OSGi bundles.

[options="step"]
Generate a bundle project with `mvn archetype:generate -Dfilter=org.apache.camel.archetypes:camel-archetype-scr`.

[options="step"]
.Work on the project
--
* Use your favorite IDE to work on the project.
* Add unit tests you can be proud of.
* Keep your source code in Git.
--

[options="step"]
I think the bundle is ready, now what?

== Step 2: Publish the bundle

[plantuml, step2_workflow, svg]
....
|Developer|
start
:Create a bundle project;
:Work on the project;
#PaleTurquoise:Publish the bundle;
|Jenkins|
:Build the bundle and upload to Nexus;
|#PaleGreen|Nexus|
:Artifact stored>
stop
....

[options="step"]
Publish the bundle with `git notifiedpush`.

[options="step"]
Custom Git alias, `notifiedpush`, works like regular `push` but also informs Jenkins CI server that we have pushed changes to central repository. Jenkins builds the bundle and stores the resulting artifact in Nexus.

[options="step"]
OK, I have the bundle artifact in a central store ready to be deployed. What next?

== Step 3: Prepare Fabric profiles

[plantuml, step3_workflow, svg]
....
|Developer|
start
#PaleTurquoise:Prepare Fabric profiles;
|?|
:?;
|UAT|
:Configuration updated;
|#PaleGreen|Production|
....

[options="step"]
Use your dev environment to create a Fabric profile for the bundle and define profile dependencies (= parent profiles).

[options="step"]
Then we just pass the configuration to other environments, right?

[options="step"]
.Right... but first answer these questions:
--
* How do we move the configuration from one Fuse to another?
* How do we control which bundles (and which versions) should run in UAT and which ones in production?
* How do we manage environment specific parameters? I.e. when our Camel routes should behave a bit differently in UAT than in prod.
--

[options="step"]
Let's pretend we have the answers and move on.

== Step 4: Publish the configuration

[plantuml, step4_workflow, svg]
....
|Developer|
start
:Prepare Fabric profiles;
#PaleTurquoise:Publish the configuration;
|Jenkins|
:Update UAT config and tag it;
|UAT|
:Configuration updated>
|#PaleGreen|Production|
....

[options="step"]
Publish the configuration with `git notifiedpush`.

[options="step"]
The configuration changes will now be deployed in User Acceptance Testing environment.

[options="step"]
When the UAT is accepted you are free to promote the configuration to production.

== Step 5: Promoting configuration to production

[plantuml, step5_workflow, svg]
....
|Developer|
start
:Prepare Fabric profiles;
:Publish the configuration;
|Jenkins|
:Update UAT config and tag it;
|UAT|
:Configuration updated>
|Developer|
#PaleTurquoise:Promote tagged config
to production;
|Jenkins|
:Update production config and tag it;
|#PaleGreen|Production|
:Configuration updated>
stop
....

[options="step"]
Select a tagged UAT configuration (typically the latest) and let Jenkins push it to production.

[options="step"]
Done.

== Demo

. Create a bundle project.
. Publish the bundle.
. Prepare Fabric profiles.
. Publish configuration.
. Promote configuration to production.

== Enabler 1: Moving configuration from one Fuse to another

Fuse keeps its configuration in Git, so we'll use Git to move the configuration.

To make sure we don't push changes to a non-master Git node Fuse has to be configured to use an external Git repostitory.

== Enabler 2: Limiting the scope of configuration changes

Although we could update the whole Fuse branch when we are passing changes around, this could create unnecessary work in form of meaningless conflicts (changed profile refresh timestamps, and the like). Instead we attach a subtree to Fuse configuration which will be the only part of the configuration hierarchy we update through our workflow.

== Enabler 3: Controlling which bundles (and versions) should run where

We'll leverage parent profile mechanism here. Every environment has its own top level profile which defines which profiles are assigned where.

On top of that, this approach makes sure we have the assignments in version control.

== Enabler 4: Managing environment specific parameters

We'll put the bundle configuration in properties and use property prefixes to cover the environment specifics.

This way every target environment is configured in the same place which makes it easy to see the big picture.

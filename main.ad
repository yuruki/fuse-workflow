= Real World Enterprise Workflow for Red Hat JBoss Fuse
Jyrki Ruuskanen, Finavia Corporation, 2014
:backend: deckjs
:deckjs_theme: swiss
:status:
:split:

== Where do we start from?

* A team of 2-3 developers who also operate the environments (got the Devs and the Ops right there).
* Red Hat JBoss Fuse license for 16 processor cores.
* Green light from the bosses to make Fuse our next integration platform.

=== What are we trying to achieve?

* A highly available setup manageable by a small team.
* Manual steps kept at minimum, while keeping the setup simple.
* Everything versioned and reversible.

[options="step"]
--
[plantuml, profit, svg]
....
start
#PaleTurquoise:Cool, we're good to go;
:?;
#PaleGreen:Profit!;
stop
....

That's the idea. Now let's go through what we got...
--

== Step 1: Create a bundle project

[plantuml, step1_workflow, svg]
....
|Developer|
start
#PaleTurquoise:Create a bundle project;
:Work on the project;
|#PaleGreen|Nexus|
....

[options="step"]
To deploy something in Fuse we first have to create a deployable artifact. In our case we create and deploy OSGi bundles.

[options="step"]
Generate a bundle project with `mvn archetype:generate -Dfilter=org.apache.camel.archetypes:camel-archetype-scr`.

[options="step"]
.Work on the project
--
* Use your favorite IDE to work on the project.
* Add unit tests you can be proud of.
* Keep your source code in Git.
--

[options="step"]
I think the bundle is ready, now what?

== Step 2: Publish the bundle

[plantuml, step2_workflow, svg]
....
|Developer|
start
:Create a bundle project;
:Work on the project;
#PaleTurquoise:Publish the bundle;
|Jenkins|
:Build the bundle and upload to Nexus;
|#PaleGreen|Nexus|
:Artifact stored>
stop
....

[options="step"]
Publish the bundle with `git notifiedpush`.

[options="step"]
Custom Git alias, `notifiedpush`, works like regular `push` but also informs Jenkins CI server that we have pushed changes to central repository. Jenkins builds the bundle and stores the resulting artifact in Nexus.

[options="step"]
OK, I have the bundle artifact in a central store ready to be deployed. What next?

== Step 3: Prepare Fabric profiles

[plantuml, step3_workflow, svg]
....
|Developer|
start
#PaleTurquoise:Prepare Fabric profiles;
|?|
:?;
|UAT|
:Configuration updated;
|#PaleGreen|Production|
....

[options="step"]
Use your dev environment to create a Fabric profile for the bundle and define profile dependencies (= parent profiles).

[options="step"]
Then we just pass the configuration to other environments, right?

[options="step"]
.Right... but first answer these questions:
--
* How do we move the configuration from one Fuse environment to another?
* How do we control which bundles (and which versions) should run in UAT and which ones in production?
* How do we manage environment specific parameters? I.e. when our Camel routes should behave a bit differently in UAT than in prod.
--

[options="step"]
Let's pretend we have the answers and move on.

== Step 4: Publish the configuration

[plantuml, step4_workflow, svg]
....
|Developer|
start
:Prepare Fabric profiles;
#PaleTurquoise:Publish the configuration;
|Jenkins|
:Update UAT config and tag it;
|UAT|
:Configuration updated>
|#PaleGreen|Production|
....

[options="step"]
Publish the configuration with `git notifiedpush`.

[options="step"]
The configuration changes will now be deployed in User Acceptance Testing environment.

[options="step"]
When the UAT is accepted you are free to promote the configuration to production.

== Step 5: Promoting configuration to production

[plantuml, step5_workflow, svg]
....
|Developer|
start
:Prepare Fabric profiles;
:Publish the configuration;
|Jenkins|
:Update UAT config and tag it;
|UAT|
:Configuration updated>
|Developer|
#PaleTurquoise:Promote tagged config
to production;
|Jenkins|
:Update production config and tag it;
|#PaleGreen|Production|
:Configuration updated>
stop
....

[options="step"]
Select a tagged UAT configuration (typically the latest) and let Jenkins push it to production.

[options="step"]
Done.

== Demo

. Create a bundle project.
. Publish the bundle.
. Prepare Fabric profiles.
. Publish configuration.
. Promote configuration to production.

== Enabler 1: Moving configuration from one Fuse to another

[plantuml, fuse_git, svg]
....
title Fuse's distributed Git server
package "Fuse Fabric" {
		component "root\ncontainer" as root
		component "child\ncontainer" as child
		component "another child\ncontainer" as child2
		http -- [root]
		interface "Git\nmaster" as master
		interface "HTTP\n(Git servlet)" as http
		[root] - master
		http ..> master : uses
		interface "Git\nslave" as git2
		[child] -- git2
		git2 ..> master : follows
		interface "Git\nslave" as git3
		[child2] -- git3
		git3 ..> master : follows
}
....

[options="step"]
* Fabric keeps its profiles in a Git repository
* This repository is exposed at `http://<server>:8181/git/fabric`

<<<

[plantuml, fuse_git2, svg]
....
package "Fuse Fabric" {
		component "root\ncontainer" as root
		component "child\ncontainer" as child
		component "another child\ncontainer" as child2
		http -- [root]
		interface "Git\nmaster" as master
		interface "HTTP\n(Git servlet)" as http
		[root] - master
		http ..> master : uses
		interface "Git\nslave" as git2
		[child] -- git2
		git2 ..> master : follows
		interface "Git\nslave" as git3
		[child2] -- git3
		git3 ..> master : follows
}
[Git client] ..> http : push and pull
note right of [Git client]
	You can use Fuse's fabric repository
	just like any other Git repository.
end note
....

[options="step"]
So, we'll just apply our changes to the tracking branch and push the changes to Fabric?

[options="step"]
You could, BUT...

<<<

[plantuml, fabric_minimum, svg]
....
package "Fabric cluster (3 nodes minimum)" {
	node "Host 3" {
		component "root\ncontainer" as root3
		component "child\ncontainer" as child3
		http3 -- [root3]
		[root3] -- [child3]
		interface "Git" as git31
		interface "HTTP\n(Git servlet)" as http3
		git31 - [root3]
		interface "Git" as git32
		git32 - [child3]
	}
	node "Host 2" {
		component "root\ncontainer" as root2
		component "child\ncontainer" as child2
		http2 -- [root2]
		[root2] -- [child2]
		interface "Git" as git21
		interface "HTTP\n(Git servlet)" as http2
		git21 - [root2]
		interface "Git" as git22
		git22 - [child2]
	}
	node "Host 1" {
		component "root\ncontainer" as root1
		component "child\ncontainer" as child1
		http1 -- [root1]
		[root1] -- [child1]
		interface "Git" as git11
		interface "HTTP\n(Git servlet)" as http1
		git11 - [root1]
		interface "Git" as git12
		git12 - [child1]
	}
}
....

[options="step"]
* Any container can be the Git master, and the master can change _at any time_.
* Push operation should be targeted to the host that has the Git master.
* Git servlet updates the Git of the root container on the same host, _not the actual master_.
* You can't force the Git master, short of shutting down every container in Fabric except one.

<<<

[plantuml, external_git, svg]
....
node "Auxiliary Server" {
	component "Git\nmaster" as master
}
package "Fabric cluster" {
	node "Host 3" {
		component "root\ncontainer" as root3
		component "child\ncontainer" as child3
		[root3] -- [child3]
		interface "Git\nslave" as git31
		git31 - [root3]
		git31 ..> master : follows
		interface "Git\nslave" as git32
		git32 - [child3]
		git32 ..> master : follows
	}
	node "Host 2" {
		component "root\ncontainer" as root2
		component "child\ncontainer" as child2
		[root2] -- [child2]
		interface "Git\nslave" as git21
		git21 - [root2]
		git21 ..> master : follows
		interface "Git\nslave" as git22
		git22 - [child2]
		git22 ..> master : follows
	}
	node "Host 1" {
		component "root\ncontainer" as root1
		component "child\ncontainer" as child1
		[root1] -- [child1]
		interface "Git\nslave" as git11
		git11 - [root1]
		git11 ..> master : follows
		interface "Git\nslave" as git12
		git12 - [child1]
		git12 ..> master : follows
	}
}
....

[options="step"]
* Set up a Git repository outside Fuse.
* Tell Fuse to use the external repository as Git master.

[options="step"]
Now everything works as it should!

== Enabler 2: Limiting the scope of configuration changes

Although we could update the whole Fuse branch when we are passing changes around, this could create unnecessary work in form of meaningless conflicts (changed profile refresh timestamps, and the like). Instead we attach a subtree to Fuse configuration which will be the only part of the configuration hierarchy we update through our workflow.

Only changes in the subtree will be moved the central repository.

== Enabler 3: Controlling which bundles (and versions) should run where

This can be achieved with the parent profile mechanism. Every environment has its own top level profile which defines other profiles as parents. The top level profile is the only profile on the container.

This approach allows us to take profile assignments into version control.

== Enabler 4: Managing environment specific parameters

We'll put the bundle configuration in properties and use property prefixes to cover the environment specifics.

This way every target environment is configured in the same place which makes it easy to see the big picture.

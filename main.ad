= Real World Enterprise Workflow for Red Hat JBoss Fuse
Jyrki Ruuskanen, Finavia Corporation, 2014
:backend: deckjs
:deckjs_theme: swiss
:status:
:split:

== Where do we start from?

* A team of 2-3 developers who also operate the environments (got the Devs and the Ops right there).
* Red Hat JBoss Fuse license for 16 processor cores.
* Green light from the bosses to make Fuse our next integration platform.

=== What are we trying to achieve?

* A highly available setup manageable by a small team.
* Manual steps kept at minimum, while keeping the setup simple.
* Everything versioned and reversible.

[options="step"]
--
[plantuml, profit, svg]
....
start
#PaleTurquoise:Cool, we're good to go;
:?;
#PaleGreen:Profit!;
stop
....

That's the idea. Now let's go through what we got...
--

== Step 1: Create a bundle project

[plantuml, step1_workflow, svg]
....
|Developer|
start
#PaleTurquoise:Create a bundle project;
:Work on the project;
|#PaleGreen|Nexus|
....

[options="step"]
To deploy something in Fuse we first have to create a deployable artifact. In our case we create and deploy OSGi bundles.

[options="step"]
Generate a bundle project with `mvn archetype:generate -Dfilter=org.apache.camel.archetypes:camel-archetype-scr`.

[options="step"]
.Work on the project
--
* Use your favorite IDE to work on the project.
* Add unit tests you can be proud of.
* Keep your source code in Git.
--

[options="step"]
I think the bundle is ready, now what?

== Step 2: Publish the bundle

[plantuml, step2_workflow, svg]
....
|Developer|
start
:Create a bundle project;
:Work on the project;
#PaleTurquoise:Publish the bundle;
|Jenkins|
:Build the bundle and upload to Nexus;
|#PaleGreen|Nexus|
:Artifact stored>
stop
....

[options="step"]
Publish the bundle with `git notifiedpush`.

[options="step"]
Custom Git alias, `notifiedpush`, works like regular `push` but also informs Jenkins CI server that we have pushed changes to central repository. Jenkins builds the bundle and stores the resulting artifact in Nexus.

[options="step"]
OK, I have the bundle artifact in a central store ready to be deployed. What next?

== Step 3: Prepare Fabric profiles

[plantuml, step3_workflow, svg]
....
|Developer|
start
#PaleTurquoise:Prepare Fabric profiles;
|?|
:?;
|UAT|
:Configuration updated;
|#PaleGreen|Production|
....

[options="step"]
Use your dev environment to create a Fabric profile for the bundle and define profile dependencies (= parent profiles).

[options="step"]
Then we just pass the configuration to other environments, right?

[options="step"]
.Right... but first answer these questions:
--
* How do we move the configuration from one Fuse environment to another?
* How do we control which bundles (and which versions) should run in UAT and which ones in production?
* How do we manage environment specific parameters? I.e. when our Camel routes should behave a bit differently in UAT than in prod.
--

[options="step"]
Let's pretend we have the answers and move on.

== Step 4: Publish the configuration

[plantuml, step4_workflow, svg]
....
|Developer|
start
:Prepare Fabric profiles;
#PaleTurquoise:Publish the configuration;
|Jenkins|
:Update UAT config and tag it;
|UAT|
:Configuration updated>
|#PaleGreen|Production|
....

[options="step"]
Publish the configuration with `git notifiedpush`.

[options="step"]
The configuration changes will now be deployed in User Acceptance Testing environment.

[options="step"]
When the UAT is accepted you are free to promote the configuration to production.

== Step 5: Promoting configuration to production

[plantuml, step5_workflow, svg]
....
|Developer|
start
:Prepare Fabric profiles;
:Publish the configuration;
|Jenkins|
:Update UAT config and tag it;
|UAT|
:Configuration updated>
|Developer|
#PaleTurquoise:Promote tagged config
to production;
|Jenkins|
:Update production config and tag it;
|#PaleGreen|Production|
:Configuration updated>
stop
....

[options="step"]
Select a tagged UAT configuration (typically the latest) and let Jenkins push it to production.

[options="step"]
Done.

== Demo

. Create a bundle project.
. Publish the bundle.
. Prepare Fabric profiles.
. Publish configuration.
. Promote configuration to production.

== Enabler 1: Moving configuration from one Fuse to another

[plantuml, fuse_git, svg]
....
package "Fabric (My dev environment)" {
	node "Desktop" {
		interface "Git" as git1
		interface "HTTP\n(Git servlet)" as http
		git1 - [root]
		http -- [root]
		http - git1
		interface "Git" as git2
		git2 - [broker]
		interface "Git" as git3
		git3 - [camel]
	}
}
package "Fabric (UAT or production)" {
	node "Host1" {
		interface "Git\n(master)" as git11
		interface "HTTP\n(Git servlet)" as http1
		git11 - [root1]
		http1 -- [root1]
		http1 - git11
		interface "Git" as git12
		git12 - [broker1]
		interface "Git" as git13
		git13 - [camel1]
	}
	node "Host 2" {
		interface "Git" as git21
		interface "HTTP\n(Git servlet)" as http2
		git21 - [root2]
		http2 -- [root2]
		http2 - git11
		interface "Git" as git22
		git22 - [broker2]
		interface "Git" as git23
		git23 - [camel2]
	}
	node "Host n" {
		interface "Git" as git31
		interface "HTTP\n(Git servlet)" as http3
		git31 - [root3]
		http3 -- [root3]
		http3 - git11
		interface "Git" as git32
		git32 - [broker3]
		interface "Git" as git33
		git33 - [camel3]
	}
}
....

Fuse Fabric comes with a distributed Git setup and keeps its configuration there. We'll use Git tools to move the configuration.

The fact that any Karaf container in Fabric may take the role of Git master makes it a moving target for push operations. Pushing to slaves is not encouraged.

To make sure we don't push changes to a non-master Git node Fuse has to be configured to use an external Git repository. This takes the timing concerns out of the equation as Fuse can update its configuration in its own pace.

== Enabler 2: Limiting the scope of configuration changes

Although we could update the whole Fuse branch when we are passing changes around, this could create unnecessary work in form of meaningless conflicts (changed profile refresh timestamps, and the like). Instead we attach a subtree to Fuse configuration which will be the only part of the configuration hierarchy we update through our workflow.

Only changes in the subtree will be moved the central repository.

== Enabler 3: Controlling which bundles (and versions) should run where

This can be achieved with the parent profile mechanism. Every environment has its own top level profile which defines other profiles as parents. The top level profile is the only profile on the container.

This approach allows us to take profile assignments into version control.

== Enabler 4: Managing environment specific parameters

We'll put the bundle configuration in properties and use property prefixes to cover the environment specifics.

This way every target environment is configured in the same place which makes it easy to see the big picture.
